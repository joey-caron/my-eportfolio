This artifact was part of a project for my CS 410: Reverse Software Engineering course. The prompt behind it was a simple client tracking program, and it was mainly to be used just to translate into assembly language, then into binary, and then back to C++. It is a very simple, single class program with a command prompt style text entry interface. I selected this artifact because while the original program was very simple, the idea behind it is a good one. It was also very barebones, which made it a great candidate for enhancement, as it could use a lot of enhancing. 

This is the same artifact I used for the Software design and engineering enhancements. As I said, this artifact is a great candidate for enhancements, as so much can be done to it. This original code had a “list” of customers included in it, but it wasn’t truly a means of storage. Everything except their enrollment status was just an output string that got printed to the screen when prompted. There was no storage of information apart from five variables, one for each “customer”, that each held either a 1 or a 2. There was no ability to actually track customers, nor to add to the list by anyone except someone with access to the source code. There was also no way to search for a specific customer. I was able to showcase my skills and abilities with data structures and algorithms by including a full compliment of CRUD methods, which allow for client base growth, updating client information, removing clients from the database and searching through the entirety of the database using almost any field in the customer table. While a bit minor, the class that handles all of the user interface components also makes use of array lists to handle dropdown menus. It should be noted that I do not have my SQLite database created yet, as that will be part of the next set of enhancements. I am confident, however, that once it is made it will tie all of the enhancements made in this round and the previous round together. 

That being said, I intend to use DBeaver to create my SQLite database in the next round of enhancements, as well as completing the code in the main Java program to tie the program to the database. The database will have two schema: a users table and a customers table. Both will be independent from each other which means there will be no foreign keys required. The primary keys will be the username in the users table, and the customer Id in the customers table. I also may go back and change some of the established code enhancements I have done thus far, and create a single class for the SQLite connection which can then be referenced where needed, rather than having so many methods establish the connection on their own as they currently do. The deciding factor on this will most likely be time constraints. 

I was able to achieve the course outcomes I intended to with this round of enhancements. I originally stated in the Module one assignment that I intended to achieve course outcomes 3 and 4: Design and evaluate computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution while managing the trade-offs involved in design choices and Demonstrate an ability to use well-founded and innovative techniques, skills, and tools in computing practices for the purpose of implementing computer solutions that deliver value and accomplish industry-specific goals.

I accomplished outcome 3 by designing a computing solution to allow for client base and company growth by implementing CRUD methods which allow the client database to be altered and added to, as well as adding users, and by creating a large amount of search algorithms. The only trade-off I felt that I had to manage was omitting the ability to search clients by their brokerage status. As the current program only allows for two options in status, and it cannot be null, it seemed to me to not be worth adding at this time. However, I do see how adding it could add value as well. If, for instance, in the future more options were to be added besides just “brokerage” and “retirement”, being able to search that may be useful. Outcome 4 was achieved by making use of well-founded and innovative techniques, skills and tools to implement the CRUD methods and search algorithms, which delivered much needed value to the program. I also achieved outcome 5, working with a security mindset, because as I was creating the CRUD methods and planning on connecting to the database, I implemented prepared statements to mitigate SQL injection issues. I do not have any updates to my outcome coverage plans further than what was stated in my Milestone 2 narrative. 

Throughout the process of creating the enhancements for this part of the project, I cannot say I really learned much. I am already very familiar with CRUD methods, so it was mainly more a matter of just getting it done. Though I will say that implementing the CRUD methods to the button clicks from the user interface and taking information from the JTextFields was new for me. I would also have to say that the hardest challenge was creating the prepared statements when I don’t yet have the database created. It was difficult at times to be sure I was being consistent with the intended column names so I had to go back at the end and double check all of it to be sure. I will be checking again once I have the database made to ensure everything is in working order. 

Performing this round of updates brought to mind the amount of growth I have experienced while going through my degree program at SNHU. When I first started, I had negligible experience with programming. I knew there were different languages, but did not know the differences between them. I knew programming was logical because of the nature of computers, but not exactly what you could and could not make a program do or how to do it. Now, I can clearly think about what I want a program to do and figure out how to make it happen. I feel that the enhancements I am making to this program really show my growth as a developer.
