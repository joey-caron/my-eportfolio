This artifact was part of a project for my CS 410: Reverse Software Engineering course. The prompt behind it was a simple client tracking program, and it was mainly to be used just to translate into assembly language, then into binary, and then back to C++. It is a very simple, single class program with a command prompt style text entry interface. I selected this artifact because while the original program was very simple, the idea behind it is a good one. It was also very barebones, which made it a great candidate for enhancement, as it could use a lot of enhancing. 

This is the same artifact I used for the last two categories. I chose this artifact mainly because there were so many enhancements that could be made. In fact, it felt more like going from a proof of concept to full application. The original code had a very simple list of clients which wasn’t even stored as a list, but rather as Strings that would be printed to the console upon command. The client list consisted of just 5 names, each had a “customer number” which was just part of the String, and the only variable was the status option of “Brokerage” or “Retirement”. Fine for a proof of concept, but not for an actual business application that is meant to be used. The enhancements made for this category go hand in hand with the previous round’s as well. For the previous category, Data structures and algorithms, I created CRUD methodology and a robust search function.

This round of enhancements was for category three, Databases. So, I created an SQLite database. I chose SQLite because this application doesn’t need a web-based database; just an embedded database is enough. I also chose SQLite over MongoDB, because I wanted the structure of a relational database. However, in terms of company growth, if the SNHU Investments company became larger, it would be wise to switch to a non-embedded database. I would most likely switch to a database made with MySQL, as it is still a relational database and would be easily transferred over, but it would be better for a larger, networked system.

The database I created in SQLite holds two tables: The first is a table of users, which holds the unique username, which is the primary key for the table, hashed password for security, employee name and job title. The other table is a customer table. It holds the unique Customer ID, which is the primary key, first name, last name, address, phone number, email and account status (brokerage or retirement). For security, I made sure to implement prepared statements to avoid SQL injection, and I made sure that after navigating away from any panel in the UI, all text entry fields would be wiped empty. With all of this, I believe I have met the course outcomes as planned in Module One, and I have no updates to my outcome-coverage plans.

While I have worked with MySQL and MongoDB databases in the past, it has been quite a while since I did that, so there was a lot of trial by fire involved with this round of enhancements. I was having to relearn the syntax as well as learning how to use prepared statements, as I had heard of them but never used them before. There was also a lot of trial and error with some of the CRUD methods once implemented with the actual SQLite database. For instance, I found through testing that even though I specifically set certain fields to be notnull, using the UPDATE methods would allow me to edit the value of a column to be null. It took some digging to figure out where the line was that was allowing the notnull rule to be circumvented. There were a few instances of this that were all quickly found and fixed. I then thoroughly retested to ensure I hadn’t broken anything else by making my fixes.

This enhancement finally ties everything I have worked on together. I believe it truly shows my growth as a programmer and my value as a software engineer. In the past few years, I have gone from not knowing the difference between C++, Java and Python, to being able to fully translate a bare bones C++ program into a fully functional Java program that could be used in a professional setting. I went from not understanding how programs communicate with each other, to building a solution that utilizes Java code, a Java UI, and implements a SQLite database seamlessly. I still have room to improve, but I have also learned and grown enough to know that even software engineers with 50 years of experience have room to grow and improve. I take a lot of pride in myself and my abilities, and I believe I have shown what I am capable of with this project.
